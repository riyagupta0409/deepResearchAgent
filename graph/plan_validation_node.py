import json

def plan_validation_node(state):
    """
    Validates the plan generated by the LLM and corrects it if necessary.
    Ensures the plan is logical and executable before the expensive execution phase.
    """
    print("---Validating and Correcting Plan---")
    plan = state.get("plan", [])
    if not plan:
        print("Warning: Plan is empty. Cannot validate.")
        return {}

    # Find all scrape steps and the summarize step
    scrape_step_ids = [step["id"] for step in plan if step.get("action") == "scrape_url"]
    summarize_step = next((step for step in plan if step.get("action") == "summarize"), None)

    # --- Correction Logic ---
    # If there's a summarize step and scrape steps, ensure the input is correct.
    if summarize_step and scrape_step_ids:
        expected_input = [f"{step_id}.content" for step_id in scrape_step_ids]
        # Check if the input is missing or incorrect
        if summarize_step.get("input") != expected_input:
            print(f"CORRECTION: Fixing summarize step input. Was: {summarize_step.get('input')}, Now: {expected_input}")
            summarize_step["input"] = expected_input

    # Ensure the plan ends with a 'finish' action
    if not plan or plan[-1].get("action") != "finish":
        print("CORRECTION: Plan does not end with 'finish'. Appending a robust finish step.")
        summarize_id = summarize_step["id"] if summarize_step else None
        if summarize_id:
            finish_input = f"{summarize_id}.summary"
        else:
            # If there's no summary, the plan is flawed. Finish with an error.
            finish_input = "Error: The research plan was flawed and could not produce a summary."
        
        plan.append({
            "id": f"step_{len(plan) + 1}",
            "action": "finish",
            "input": finish_input
        })

    print(f"Validated Plan: {json.dumps(plan, indent=2)}")
    return {"plan": plan}
